//不带头结点的单链表
typedef struct LNode{     //定义单链表结点类型
	ElemType data;        //每个节点存放一个数据元素
	struct LNode *next;   //指针指向下一个结点
}LNode,*LinkList;
//初始化一个空的单链表
bool InitList(LinkList &L){
	L=NULL;           //空表，暂时还没有结点
	return true;
}
void test(){
	LinkList L;        //声明一个指向单链表的指针
	InitList(L);
}
//判断单链表是否为空
bool Empty(LinkList L){
	return(L==NULL);
}



//带头结点的单链表
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
//初始化一个单链表（带头结点）
bool InitList(LinkList &L){
	L=(LNode *)malloc(sizeof(LNode));   //分配一个头结点
	if(L==NULL){         //内存不足，分配失败
		return false;
	}
	L->next=NULL;        //头结点之后暂时还没有节点
	return true;
}
void test(){
	LinkList L;           //声明一个指向单链表的指针
	InitList(L);         //初始化一个空表
}



//单链表的插入
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
//初始化一个单链表（带头结点）
bool InitList(LinkList &L){
	L=(LNode *)malloc(sizeof(LNode));   //分配一个头结点
	if(L==NULL){         //内存不足，分配失败
		return false;
	}
	L->next=NULL;        //头结点之后暂时还没有节点
	return true;
}
void test(){
	LinkList L;           //声明一个指向单链表的指针
	InitList(L);         //初始化一个空表
}

//在第i个位置插入元素e
bool ListInsert(LinkList &L,int i,ElemType e){
	if(i<1)
	   return false;
	LNode *p;      //指针p指向当前扫描到的结点
	int j=0;       //当前p指向的是第几个结点
	p=L;           // L指向头结点，头结点是第0个结点（不存数据）
	while(p!=NULL&&j<i-1){   //循环找到第i-1个结点，用于在第几个结点插入数据，很关键
		p=p->next;
		j++;
	}
	if(p==NULL)    //针对i的数值太大，已经超过现有的结点个数，则i的值不合法
	   return false;
	LNode *s=(LNode *)malloc(sizeof(LNode));
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}

//前插操作：在p结点之前插入元素e
bool InsertPriorNode(LNode *p,ElemType e){
	if(p==NULL)
	   return false;
	LNode *s=(LNode *)malloc(sizeof(LNode));
	if(s==NULL)
	   return false;
	s->next=p->next;//将s放在p结点之后
	p->next=s;       //新结点s连到p之后
	s->data=p->data; //将p的元素复制给s
	p->data=e;        //p元素的值覆盖为e
	return true;
}

//按位序删除

bool ListInsert(LinkList &L,int i,ElemType &e){//e的值需要返回，所以和插入不一样
	if(i<1)
	   return false;
	LNode *p;      //指针p指向当前扫描到的结点
	int j=0;       //当前p指向的是第几个结点
	p=L;           // L指向头结点，头结点是第0个结点（不存数据）
	while(p!=NULL&&j<i-1){   //循环找到第i-1个结点，用于在第几个结点插入数据，很关键
		p=p->next;
		j++;
	}
	if(p==NULL)    //针对i的数值太大，已经超过现有的结点个数，则i的值不合法
	   return false;
	if(p->next==NULL)
	   return false;
	LNode *q=p->next;  //令q指向被删除结点
	e=q->data;         //用e返回元素的值
	p->next=q->next;   // 将*q结点从链中断开
	free(q);            //释放结点的存储空间
	return true;
}
