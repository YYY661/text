//不带头结点的单链表
typedef struct LNode{     //定义单链表结点类型
	ElemType data;        //每个节点存放一个数据元素
	struct LNode *next;   //指针指向下一个结点
}LNode,*LinkList;
//初始化一个空的单链表
bool InitList(LinkList &L){
	L=NULL;           //空表，暂时还没有结点
	return true;
}
void test(){
	LinkList L;        //声明一个指向单链表的指针
	InitList(L);
}
//判断单链表是否为空
bool Empty(LinkList L){
	return(L==NULL);
}



//带头结点的单链表
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
//初始化一个单链表（带头结点）
bool InitList(LinkList &L){
	L=(LNode *)malloc(sizeof(LNode));   //分配一个头结点
	if(L==NULL){         //内存不足，分配失败
		return false;
	}
	L->next=NULL;        //头结点之后暂时还没有节点
	return true;
}
void test(){
	LinkList L;           //声明一个指向单链表的指针
	InitList(L);         //初始化一个空表
}



//单链表的插入
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
//初始化一个单链表（带头结点）
bool InitList(LinkList &L){
	L=(LNode *)malloc(sizeof(LNode));   //分配一个头结点
	if(L==NULL){         //内存不足，分配失败
		return false;
	}
	L->next=NULL;        //头结点之后暂时还没有节点
	return true;
}
void test(){
	LinkList L;           //声明一个指向单链表的指针
	InitList(L);         //初始化一个空表
}

//在第i个位置插入元素e
bool ListInsert(LinkList &L,int i,ElemType e){
	if(i<1)
	   return false;
	LNode *p;      //指针p指向当前扫描到的结点
	int j=0;       //当前p指向的是第几个结点
	p=L;           // L指向头结点，头结点是第0个结点（不存数据）
	while(p!=NULL&&j<i-1){   //循环找到第i-1个结点，用于在第几个结点插入数据，很关键
		p=p->next;
		j++;
	}
	if(p==NULL)    //针对i的数值太大，已经超过现有的结点个数，则i的值不合法
	   return false;
	LNode *s=(LNode *)malloc(sizeof(LNode));
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}

//前插操作：在p结点之前插入元素e
bool InsertPriorNode(LNode *p,ElemType e){
	if(p==NULL)
	   return false;
	LNode *s=(LNode *)malloc(sizeof(LNode));
	if(s==NULL)
	   return false;
	s->next=p->next;//将s放在p结点之后
	p->next=s;       //新结点s连到p之后
	s->data=p->data; //将p的元素复制给s
	p->data=e;        //p元素的值覆盖为e
	return true;
}

//按位序删除

bool ListInsert(LinkList &L,int i,ElemType &e){//e的值需要返回，所以和插入不一样
	if(i<1)
	   return false;
	LNode *p;      //指针p指向当前扫描到的结点
	int j=0;       //当前p指向的是第几个结点
	p=L;           // L指向头结点，头结点是第0个结点（不存数据）
	while(p!=NULL&&j<i-1){   //循环找到第i-1个结点，用于在第几个结点插入数据，很关键
		p=p->next;
		j++;
	}
	if(p==NULL)    //针对i的数值太大，已经超过现有的结点个数，则i的值不合法
	   return false;
	if(p->next==NULL)
	   return false;
	LNode *q=p->next;  //令q指向被删除结点
	e=q->data;         //用e返回元素的值
	p->next=q->next;   // 将*q结点从链中断开
	free(q);            //释放结点的存储空间
	return true;
}

//删除指定结点p，需要修改p的前驱结点的next指针
bool DeleteNode(LNode *p){
     if(p==NULL)
        return false;
     LNode *q=p->next;
     p->data=p->next->data;
     p->next=q->next;
     free(q);
     return true;
}

//如果p结点是最后一个结点，传入一个头结点，利用循环从头结点开始寻找指定结点p的前驱结点



//单链表的查找
//按位查找，返回第i个元素
LNode * GetElem(LinkList L,int i){
if(i<0)
   return false;
LNode *p;       //指针p指向当前扫描到的结点
int j=0;         //当前p指向的是第几个结点
p=L;            //L指向头结点，头结点是第0个结点（不存数据）
while(p!=NULL&&j<i){   //循环找到第i个结点
     p=p->next;
     j++;
}
return p;
}

//按值查找，找到数据域==e的结点
LNode * LocateElem(LinkList L,ElemType e){
    LNode *p=L->next;
        //从第一个结点开始查找数据域为e的结点
    while(p!=NULL&&p->data!=e)
         p=p->next;
    return p;   //找到后返回该结点指针，否则返回NULL
}


//求表的长度
int length(LinkList L){
    int len=0;
    LNode *p=L;
    while(p->next!=NULL){
         p=p->next;
         len++;
    }
    return len;
}


//单链表的建立
//尾插法建立单链表（可以用按位序插入的操作来实现）
typedef struct LNode{
        ElemType data;
        struct LNode *next;
}LNode,*LinkList;
//初始化一个单链表
bool InitList(LinkList &L){
    L=(LNode *)malloc(sizeof(LNode));
    if(L==NULL)      //内存不足，分配失败
       return false;
    L->next=NULL;    //头结点之后暂时还没有结点
    return true;
}
void test(){
     LinkList L;
     InitList(L);
}
int length;
while{
     ListInsert(L,length+1,e)   //调用按位序插入的函数
     length++;
}

//尾插法（设置一个表尾指针，执行一个后插操作）
bool InsertNextNode(LNode *p,ElemType e){
     if(p==NULL)
       return flase;
     LNode *s=(LNode *)malloc(sizeof(LNode);
     if(s==NULL)
       return flase;
     s->data=e;
     s->next=p->next;
     p->next=s;
     return true;
}




