#include<stdio.h>
#define MaxSize 10
typedef struct{
	int data[MaxSize];
	int length;
}SqList;
void InitList(SqList &L){
	for(int i=0;i<L.length;i++){
		L.data[i]=0;
	}
	L.length=0;
}
int main(){
	SqList L;
	InitList(L);
	return 0;
}


//动态分配
#include<stdlib.h>
#define InitSize 10
typedef struct{
	int *data;
	int MaxSize;
	int length;
}SeqList;
void InitList(SeqList &L){
	L.data=(int *)malloc(sizeof(int)*InitSise);
	L.length=0;
	L.MaxSize=InitSize;
}
//增加动态数组的长度
void IncreaseSize(SeqList &L,int len){
	int *p;
	L.data=(int *)malloc((L.MaxSize+len)*sizeof(int));
	for(int i=0;i<L.length;i++){
		L.data[i]=p[i];
	}
	L.MaxSize=L.MaxSize+len;
	free(p);
}
int main(){
	SeqList L;//声明一个顺序表
	InitList(L);//初始化顺序表
	//在顺序表中插入元素的操作
	IncreaseSize(L,5);
	return 0;
}

//顺序表的插入（基于静态分配）
#include<stdio.h>
#define MaxSize 10
typedef struct{
	int data[MaxSize];
	int length;
}SqList;
void LiseInsert(SqList &L,int i,int e){
	for(int j=L.length;j>=i;j--){
		L.data[j]=L.data[j-1];
	}
	L.data[i-1]=e;
	L.length++;
}
int main(){
	SqList L;
	InitList(L);
	//省略插入几个元素
	ListInsert(L,3,3);
	return 0;
}

//顺序表的插入（优化版）
#include<stdio.h>
#define MaxSize 10
typedef struct{
	int data[MaxSize];
	int length;
}SqList;
bool ListInsert(SqList &L,int i,int e){
	if(i<1||i>L.length+1)
	   return false;
	if(L.length>=MaxSize)
	   return false;
	for(int i=L.length;j>=i;j--)
	    L.data[j]=L.data[j-1];
	L.data[i-1]=e;
	L.length++;
	return true;
}
int main(){
	SqList L;
	InitList(L);
	//省略插入几个元素
	ListInsert(L,3,3);
	return 0;
}


//顺序表的删除
#include<stdio.h>
#define MaxSize 10
typedef struct{
	int data[MaxSize];
	int length;
}SqList;
bool ListDelete(SqList &L,int i,int &e){
	if(i<1||i>L.length)
	   return false;
	e=L.data[i-1];
	for(int j=i;i<L.length;j++)
	    L.data[j-1]=L.data[j];
	L.length--;
	return true;
}
int main(){
	SqList L;
	InitList(L);
	//省略一些代码
	int e=-1;
	if(ListDelete(L,3,e))
	   printf("已删除第3个元素，删除元素值为=%d\n",e);
	else 
	   printf("位序i不合法，删除失败\n");
	return 0;
}


//顺序表的查找
#include<stdio.h>
#define 
